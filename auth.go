package main

import (
	"bytes"
	"encoding/base64"
	"encoding/binary"
	"fmt"
	"math/rand"
	"os"
	"strings"
	"text/template"
	"time"
)

const nounceLen = 5

var auth struct {
	user   string
	passwd string

	required bool
	authed   *TimeoutSet // cache authentication based on client i

	nounceKey [nounceLen]byte
	headTmpl  *template.Template
	bodyTmpl  *template.Template
}

func initAuth() {
	if config.UserPasswd == "" {
		return
	}

	// userPasswd validated in config/cmdline parsing
	arr := strings.SplitN(config.UserPasswd, ":", 2)
	auth.user, auth.passwd = arr[0], arr[1]

	debug.Println("requires auth")
	auth.required = true
	auth.authed = NewTimeoutSet(time.Duration(config.AuthTimeout) * time.Hour)

	rand.Seed(time.Now().Unix())
	for i := 0; i < nounceLen; i++ {
		auth.nounceKey[i] = byte(rand.Intn(255))
	}

	const authRawHeadTmpl = "HTTP/1.1 407 Proxy Authentication Required\r\n" +
		"Proxy-Authenticate: Digest realm=\"COW proxy\", nonce=\"{{.Nounce}}\"\r\n" +
		"Content-Type: text/html\r\n" +
		"Cache-Control: no-cache\r\n" +
		"Connection: keep-alive\r\n" +
		"Content-Length: {{.Length}}\r\n"
	const authRawBodyTmpl = `<!DOCTYPE html>
<html>
	<head> <title>COW Proxy</title> </head>
	<body>
		<h1>407 Proxy authentication required</h1>
		<hr />
		Generated by <i>COW</i> at {{.T}}
	</body>
</html>
`
	var err error
	auth.headTmpl, err = template.New("authHead").Parse(authRawHeadTmpl)
	if err != nil {
		fmt.Println("Internal error generating authHead template:", err)
		os.Exit(1)
	}
	auth.bodyTmpl, err = template.New("authBody").Parse(authRawBodyTmpl)
	if err != nil {
		fmt.Println("Internal error generating authBody template:", err)
		os.Exit(1)
	}
}

// Return true if authentication succeed
func authenticate(conn *clientConn, r *Request) bool {
	return authUserPasswd(conn, r)
}

func genNounce() string {
	src := new(bytes.Buffer)
	binary.Write(src, binary.LittleEndian, time.Now().Unix())
	for i := 0; i < nounceLen; i++ {
		binary.Write(src, binary.LittleEndian, auth.nounceKey[i])
	}
	return base64.StdEncoding.EncodeToString(src.Bytes())
}

func authUserPasswd(conn *clientConn, r *Request) bool {
	body := new(bytes.Buffer)
	bodyData := struct {
		T string
	}{
		time.Now().Format(time.ANSIC),
	}
	if err := auth.bodyTmpl.Execute(body, bodyData); err != nil {
		errl.Println("Error generating auth response body:", err)
		return false
	}

	headData := struct {
		Nounce string
		Length int
	}{
		genNounce(),
		body.Len(),
	}

	head := new(bytes.Buffer)
	if err := auth.headTmpl.Execute(head, headData); err != nil {
		errl.Println("Error generating auth response header:", err)
		return false
	}
	debug.Println("auth response:")
	debug.Printf(head.String())
	conn.Write(head.Bytes())
	conn.Write(CRLFbytes)
	conn.Write(body.Bytes())
	return false
}
